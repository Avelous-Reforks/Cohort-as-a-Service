// packages/hardhat/scripts/generatePonderConfig.ts
import * as fs from "fs";
import * as path from "path";
import prettier from "prettier";

interface DeploymentData {
  address: string;
  receipt: {
    blockNumber: number;
  };
  abi: any[];
}

async function generatePonderConfig() {
  const deploymentsDir = "./deployments";
  const ponderPath = "../ponder";
  const ponderConfigPath = path.join(ponderPath, "src/config/chains.ts");
  const ponderAbisPath = path.join(ponderPath, "abis");

  // Ensure directories exist
  if (!fs.existsSync(path.join(ponderPath, "src/config"))) {
    fs.mkdirSync(path.join(ponderPath, "src/config"), { recursive: true });
  }
  if (!fs.existsSync(ponderAbisPath)) {
    fs.mkdirSync(ponderAbisPath, { recursive: true });
  }

  const chains: Record<string, any> = {};
  const cohortFactoryContracts: Record<string, any> = {};

  // Map chain IDs to names
  const chainIdToName: Record<string, string> = {
    "1": "mainnet",
    "137": "polygon",
    "42161": "arbitrum",
    "10": "optimism",
    "8453": "base",
    "84532": "baseSepolia",
    "11155420": "optimismSepolia",
    "534352": "scroll",
    "31337": "localhost",
  };

  if (!fs.existsSync(deploymentsDir)) {
    console.log("No deployments directory found. Run 'yarn deploy' first.");
    return;
  }

  // Read all deployments
  const chainDirs = fs
    .readdirSync(deploymentsDir)
    .filter(
      dir =>
        fs.statSync(path.join(deploymentsDir, dir)).isDirectory() &&
        fs.existsSync(path.join(deploymentsDir, dir, ".chainId")),
    );

  for (const chainDir of chainDirs) {
    const chainId = fs.readFileSync(path.join(deploymentsDir, chainDir, ".chainId"), "utf8").trim();
    const chainName = chainIdToName[chainId] || chainDir;

    // Add chain config (updated format for Ponder v1.0+)
    chains[chainName] = {
      id: Number(chainId),
      rpc: `process.env.PONDER_RPC_URL_${chainId}`,
    };

    // Check for CohortFactory deployment
    const factoryPath = path.join(deploymentsDir, chainDir, "CohortFactory.json");
    if (fs.existsSync(factoryPath)) {
      const deployment: DeploymentData = JSON.parse(fs.readFileSync(factoryPath, "utf8"));

      cohortFactoryContracts[chainName] = {
        address: deployment.address as `0x${string}`,
        startBlock: deployment.receipt.blockNumber,
      };
    }
  }

  // Copy ABIs from artifacts
  const cohortFactoryArtifact = path.join("./artifacts/contracts/CohortFactory.sol/CohortFactory.json");
  const cohortArtifact = path.join("./artifacts/contracts/Cohort.sol/Cohort.json");

  if (fs.existsSync(cohortFactoryArtifact)) {
    const artifact = JSON.parse(fs.readFileSync(cohortFactoryArtifact, "utf8"));
    const abiContent = `// Auto-generated ABI
export const CohortFactoryAbi = ${JSON.stringify(artifact.abi, null, 2)} as const;`;
    fs.writeFileSync(path.join(ponderAbisPath, "CohortFactory.ts"), abiContent);
  }

  if (fs.existsSync(cohortArtifact)) {
    const artifact = JSON.parse(fs.readFileSync(cohortArtifact, "utf8"));
    const abiContent = `// Auto-generated ABI
export const CohortAbi = ${JSON.stringify(artifact.abi, null, 2)} as const;`;
    fs.writeFileSync(path.join(ponderAbisPath, "Cohort.ts"), abiContent);
  }

  // Generate config file with updated format
  const configContent = `// This file is auto-generated by generatePonderConfig.ts
// Updated for Ponder v1.0+ configuration format

export const chainConfigs = {
  chains: ${JSON.stringify(chains, null, 2).replace(
    /"process\.env\.PONDER_RPC_URL_(\d+)"/g,
    "process.env.PONDER_RPC_URL_$1",
  )},
  cohortFactoryContracts: ${JSON.stringify(cohortFactoryContracts, null, 2)},
};
`;

  const formattedConfig = await prettier.format(configContent, {
    parser: "typescript",
    printWidth: 100,
    singleQuote: false,
    trailingComma: "all",
  });

  fs.writeFileSync(ponderConfigPath, formattedConfig);

  // Create tsconfig.json for ponder if it doesn't exist
  const ponderTsConfig = path.join(ponderPath, "tsconfig.json");
  if (!fs.existsSync(ponderTsConfig)) {
    const tsConfig = {
      compilerOptions: {
        target: "es2020",
        module: "esnext",
        lib: ["es2020"],
        moduleResolution: "bundler",
        strict: true,
        esModuleInterop: true,
        skipLibCheck: true,
        forceConsistentCasingInFileNames: true,
        resolveJsonModule: true,
        isolatedModules: true,
        noEmit: true,
        allowSyntheticDefaultImports: true,
      },
      include: ["src/**/*", "ponder.config.ts", "ponder.schema.ts", "abis/**/*"],
      exclude: ["node_modules"],
    };

    fs.writeFileSync(ponderTsConfig, JSON.stringify(tsConfig, null, 2));
    console.log(`üìù Created tsconfig.json at ${ponderTsConfig}`);
  }

  // Create .env.local template if it doesn't exist
  const envPath = path.join(ponderPath, ".env.local");
  if (!fs.existsSync(envPath)) {
    const envContent = `# Database connection (optional - uses PGlite by default)
DATABASE_URL=

# RPC URLs for each chain
PONDER_RPC_URL_1=https://eth-mainnet.g.alchemy.com/v2/YOUR_KEY
PONDER_RPC_URL_137=https://polygon-mainnet.g.alchemy.com/v2/YOUR_KEY
PONDER_RPC_URL_42161=https://arb-mainnet.g.alchemy.com/v2/YOUR_KEY
PONDER_RPC_URL_10=https://opt-mainnet.g.alchemy.com/v2/YOUR_KEY
PONDER_RPC_URL_8453=https://base-mainnet.g.alchemy.com/v2/YOUR_KEY
PONDER_RPC_URL_84532=https://base-sepolia.g.alchemy.com/v2/YOUR_KEY
PONDER_RPC_URL_11155420=https://optimism-sepolia.g.alchemy.com/v2/YOUR_KEY
PONDER_RPC_URL_534352=https://rpc.scroll.io
PONDER_RPC_URL_31337=http://localhost:8545
`;

    fs.writeFileSync(envPath, envContent);
    console.log(`üìù Created .env.local template at ${envPath}`);
  }

  // Generate updated ponder.config.ts that matches the new format
  const mainConfigPath = path.join(ponderPath, "ponder.config.ts");
  if (!fs.existsSync(mainConfigPath)) {
    const mainConfigContent = `import { createConfig, factory } from "ponder";
import { CohortFactoryAbi } from "./abis/CohortFactory";
import { CohortAbi } from "./abis/Cohort";
import { chainConfigs } from "./src/config/chains";

export default createConfig({
  database: {
    kind: process.env.DATABASE_URL ? "postgres" : "pglite",
    connectionString: process.env.DATABASE_URL,
  },
  ordering: "multichain", // Important for multichain apps
  chains: chainConfigs.chains,
  contracts: {
    CohortFactory: {
      abi: CohortFactoryAbi,
      chain: Object.keys(chainConfigs.cohortFactoryContracts),
      address: Object.values(chainConfigs.cohortFactoryContracts).map(
        (config: any) => config.address
      ),
      startBlock: Object.values(chainConfigs.cohortFactoryContracts).reduce(
        (acc: any, config: any, index: number) => {
          const chainName = Object.keys(chainConfigs.cohortFactoryContracts)[index];
          acc[chainName] = config.startBlock;
          return acc;
        },
        {}
      ),
    },
    // Dynamic Cohort contracts will be registered via factory pattern
    Cohort: {
      abi: CohortAbi,
      chain: Object.keys(chainConfigs.cohortFactoryContracts),
      address: factory({
        address: "CohortFactory",
        event: "CohortCreated",
        parameter: "cohortAddress",
      }),
      startBlock: Object.values(chainConfigs.cohortFactoryContracts).reduce(
        (acc: any, config: any, index: number) => {
          const chainName = Object.keys(chainConfigs.cohortFactoryContracts)[index];
          acc[chainName] = config.startBlock;
          return acc;
        },
        {}
      ),
    },
  },
});
`;

    const formattedMainConfig = await prettier.format(mainConfigContent, {
      parser: "typescript",
      printWidth: 100,
      singleQuote: false,
      trailingComma: "all",
    });

    fs.writeFileSync(mainConfigPath, formattedMainConfig);
    console.log(`üìù Created ponder.config.ts at ${mainConfigPath}`);
  }

  console.log(`‚úÖ Generated Ponder config at ${ponderConfigPath}`);
  console.log(`‚úÖ Copied ABIs to ${ponderAbisPath}`);
  console.log(`‚úÖ Setup complete! Available chains: ${Object.keys(chains).join(", ")}`);
}

// Run if called directly
if (require.main === module) {
  generatePonderConfig().catch(console.error);
}

export default generatePonderConfig;
