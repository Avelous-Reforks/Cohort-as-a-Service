import * as fs from "fs";
import prettier from "prettier";
import path from "path";
import { exec } from "child_process";
import { promisify } from "util";

const execAsync = promisify(exec);

const CONTRACTS_DIR = "./contracts";
const TARGET_DIR = "../nextjs/contracts/sourceFiles";
const TEMP_DIR = "./temp";

const generatedSourceComment = `/**
 * This file is autogenerated.
 * You should not edit it manually or your changes might be overwritten.
 */`;

async function flattenContract(contractPath: string): Promise<string> {
  // Create temp directory if it doesn't exist
  if (!fs.existsSync(TEMP_DIR)) {
    fs.mkdirSync(TEMP_DIR, { recursive: true });
  }

  const outputPath = path.join(TEMP_DIR, `${path.basename(contractPath)}.flat`);
  
  try {
    // Use hardhat to flatten the contract
    await execAsync(`npx hardhat flatten ${contractPath} > ${outputPath}`);
    const flattenedCode = fs.readFileSync(outputPath, "utf8");
    
    // Clean up duplicate SPDX license identifiers and pragma statements
    const cleanedCode = flattenedCode
      .replace(/\/\/ SPDX-License-Identifier: .*\n/g, "")
      .replace(/pragma solidity .*\n/g, "")
      .trim();
    
    // Add back a single license identifier and pragma statement
    return `// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n${cleanedCode}`;
  } catch (error) {
    console.error(`Error flattening contract at ${contractPath}:`, error);
    return "";
  } finally {
    // Clean up temp file
    if (fs.existsSync(outputPath)) {
      fs.unlinkSync(outputPath);
    }
  }
}

function getContractName(filePath: string): string {
  return path.basename(filePath, ".sol");
}

async function generateSourceFiles() {
  // Create target directory if it doesn't exist
  if (!fs.existsSync(TARGET_DIR)) {
    fs.mkdirSync(TARGET_DIR, { recursive: true });
  }

  // Read all .sol files from contracts directory
  const contractFiles = fs.readdirSync(CONTRACTS_DIR).filter(file => file.endsWith(".sol"));

  for (const contractFile of contractFiles) {
    const contractPath = path.join(CONTRACTS_DIR, contractFile);
    const contractName = getContractName(contractFile);
    
    // Get flattened source code with all dependencies
    const sourceCode = await flattenContract(contractPath);
    
    // Escape backticks in the source code
    const escapedSource = sourceCode.replace(/`/g, "\\`");
    
    // Generate TypeScript file content without formatting the Solidity code
    const tsContent = `${generatedSourceComment}\n\nconst source = \`${escapedSource}\` as const;\n\nexport default source;\n`;

    // Format only the TypeScript wrapper structure
    const formattedContent = await prettier.format(tsContent, {
      parser: "typescript",
      printWidth: 120,
      singleQuote: true,
    });

    fs.writeFileSync(
      path.join(TARGET_DIR, `${contractName}.ts`), 
      formattedContent
    );

    console.log(`üìù Generated flattened source file for ${contractName} at ${TARGET_DIR}/${contractName}.ts`);
  }

  // Clean up temp directory
  if (fs.existsSync(TEMP_DIR)) {
    fs.rmdirSync(TEMP_DIR, { recursive: true });
  }
}

export default generateSourceFiles;